var async_pyodide_src='\nimport asyncio,selectors,sys,js\n\nclass JSSelector(selectors.BaseSelector):\n    def __init__(self):\n        super().__init__()\n        self.keyMap={}\n        self.delay=-1\n        \n    def register(self,fileobj, events, data=None):\n        self.keyMap[fileobj]=SelectorKey(fileobj=fileobj,events=events,data=data)\n        \n    def unregister(self,fileobj):\n        self.keymap.remove(fileobj)\n        \n    def modify(self,fileobj, events, data=None):\n        self.register(fileobj,events,data)\n        \n    def select(self,timeout=None):\n        if timeout==None:\n            self.delay=-1\n        else:\n            self.delay=timeout\n        return []\n        \n    def get_map(self):\n        return self.keymap\n    \n    def get_delay(self):\n        return self.delay\n\nclass CustomLoop(asyncio.BaseEventLoop):\n    def __init__(self):\n        self.in_tick=False\n        self._selector=JSSelector()\n        super().__init__()\n        asyncio.set_event_loop(self)\n        self.started=False\n        \n    def get_delay(self):\n        return self._selector.get_delay()\n        \n    def _process_events(self,events):\n        pass\n    \n    def start(self):\n        js.eval("""\n            var pyodide_async_loop_id=-1;\n            function pyodide_async_tick()\n            {\n        \t    loop=pyodide.globals.asyncio.get_event_loop()\n        \t    loop._run_once();\n        \t    pyodide_async_timeout=loop.get_delay()\n                console.log("tick:"+pyodide_async_timeout)\n                if(pyodide_async_loop_id!=-1)\n\t            {\n        \t\t    window.clearInterval(pyodide_async_loop_id);\n        \t\t}\n        \t\tif(pyodide_async_timeout>=0)\n        \t\t{\n\t\t            pyodide_async_loop_id=window.setTimeout(pyodide_async_tick,pyodide_async_timeout*1000)\n    \t        }\n            }\n        """)\n        self.started=True\n        asyncio.events._set_running_loop(self)\n        js.pyodide_async_tick()        \n    \n    def _run_once(self):\n        self.in_tick=True\n        retVal=super()._run_once()\n        self.in_tick=False\n        return retVal\n    \n    def call_later(self, delay, callback, *args):\n        retVal=super().call_later(delay,callback,*args)\n        if not self.in_tick and self.started:\n            js.pyodide_async_tick()\n        return retVal\n    \n    def call_soon(self, callback, *args, context=None):\n        retVal= super().call_soon(callback,*args,context=context)\n        if not self.in_tick and self.started:\n            js.pyodide_async_tick()\n        return retVal\n\n    def call_at(self, when, callback, *args, context=None):\n        retVal= super().call_at(when,callback,*args,context=context)\n        if not self.in_tick and self.started:\n            js.pyodide_async_tick()\n        return retVal\n\n    def set_task_to_run_until_done(self,mainTask):\n        asyncio.set_event_loop(self)\n        task=self.create_task(self.stop_when_task_done(mainTask))\n        self.start()\n    \n    async def stop_when_task_done(self,future):\n        try:\n            future=asyncio.tasks.ensure_future(future)\n            await future\n        except:\n            if future.done() and not future.cancelled():\n                # The coroutine raised a BaseException. Consume the exception\n                # to not log a warning, the caller doesn\'t have access to the\n                # local task.\n                future.exception()\n            raise\n        if not future.done():\n            raise RuntimeError(\'Event loop stopped before Future completed.\')\n        return future.result()\n                \n\n\n';function async_pyodide_load(){pyodide.runPython("\nimport js\t\t\t\nimport importlib.util\nspec = importlib.util.spec_from_loader('async_pyodide', loader=None, origin=\"async_pyodide.py\")\nasync_pyodide = importlib.util.module_from_spec(spec)\nsys.modules['async_pyodide']=async_pyodide\t\t\nexec(js.async_pyodide_src, async_pyodide.__dict__)\n\t")}